<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Doa&#39;s blog</title>
    <link>https://motal.github.io/tags/go/</link>
    <description>Recent content in go on Doa&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <copyright>&amp;copy; 2020. All rights reserved.</copyright>
    <lastBuildDate>Sun, 29 Nov 2020 10:25:19 +0900</lastBuildDate><atom:link href="https://motal.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Golang] Goroutine을 이용한 분산처리</title>
      <link>https://motal.github.io/post/golang-goroutine%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/</link>
      <pubDate>Sun, 29 Nov 2020 10:25:19 +0900</pubDate>
      
      <guid>https://motal.github.io/post/golang-goroutine%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%84%EC%82%B0%EC%B2%98%EB%A6%AC/</guid>
      <description>피보나치를 일꾼 4명에게 동시에 계산하도록 만들어보자.
설명  worker는 일꾼이고 모두 goroutine으로 실행된다. jobs와 results는 각각 작업들과 결과물들을 전달하는 buffered 채널이다. worker 내부에는 jobs 채널로 부터 일을 계속 수신하고 그 결과는 results 채널로 전달한다. jobs 채널에 0~99까지의 작업을 전달한다. jobs에는 총 100개의 작업을 전달하고 jobs 채널을 종료(close)한다. 메인 스레드는 results 채널에서 오는 결과를 기다리고 있다.  코드 func main() { jobs := make(chan int, 100) results := make(chan string, 100) for i := 0; i &amp;lt; 100; i++ { jobs &amp;lt;- i } close(jobs) go worker(1, jobs, results) go worker(2, jobs, results) go worker(3, jobs, results) go worker(4, jobs, results) for i := 0; i &amp;lt; 100; i++ { fmt.</description>
    </item>
    
    <item>
      <title>[Golang] 포인터 리시버 vs 밸류 리시버</title>
      <link>https://motal.github.io/post/golang-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%A6%AC%EC%8B%9C%EB%B2%84-vs-%EB%B0%B8%EB%A5%98-%EB%A6%AC%EC%8B%9C%EB%B2%84/</link>
      <pubDate>Thu, 26 Nov 2020 09:38:28 +0900</pubDate>
      
      <guid>https://motal.github.io/post/golang-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%A6%AC%EC%8B%9C%EB%B2%84-vs-%EB%B0%B8%EB%A5%98-%EB%A6%AC%EC%8B%9C%EB%B2%84/</guid>
      <description>Value receiver와 Pointer receiver, 2가지가 receiver가 있다.
아래와 같은 구조체가 있다고 가정하고
type Person struct { Name string } Value receiver의 예
func (p Person) String() string { return p.Name + &amp;quot;!!!&amp;quot; } Pointer receiver의 예
func (p *Person) String() string { return p.Name + &amp;quot;!!!&amp;quot; } 두 가지 receiver를 언제 어떻게 사용해야하는지 헷갈려서 공부한 내용을 기록한다.
 우선 아래의 원칙을 알아야 한다.
원칙1. 둘 중에 한 가지만 정의할 수 있다.</description>
    </item>
    
    <item>
      <title>왜 Go를 사용하는가</title>
      <link>https://motal.github.io/post/%EC%99%9C-go%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80/</link>
      <pubDate>Mon, 23 Nov 2020 12:18:39 +0900</pubDate>
      
      <guid>https://motal.github.io/post/%EC%99%9C-go%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80/</guid>
      <description>1. 간단하다.  25개 키워드. 끝. (https://golang.org/ref/spec#Keywords) Java 49개 (https://www.geeksforgeeks.org/list-of-all-java-keywords/) c++17 84개 (https://boycoding.tistory.com/140) =&amp;gt; 배우기 쉽고 읽기도 쉽다.  2. 성능이 좋다  Java 대비 빠른 실행속도 및 훨씬 적은 메모리 사용 (https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html) binary 빌드 &amp;amp; 배포가능. no runtime environment! =&amp;gt; 서버 운영비용 감소  3. 훌륭한 생태계  docker, kubernetes, prometheus와 같은 유명한 SW존재 오픈소스도 활발하게 개발되고 있음 Google (https://github.com/google) Netflix (https://github.com/Netflix) Grab (https://github.com/grab) Uber (https://github.com/uber) Golang Korea (https://web.facebook.com/groups/golangko/) 관심도 증가 중(https://trends.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://motal.github.io/post/goisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://motal.github.io/post/goisforlovers/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://motal.github.io/post/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://motal.github.io/post/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at installing hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
  </channel>
</rss>
