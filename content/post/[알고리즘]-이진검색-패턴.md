---
title: "[알고리즘] 이진검색 패턴"
date: 2020-12-04T13:50:34+09:00
draft: false
tags: [
    "알고리즘",
    "이진검색",
]
---

이진검색을 구현하는 것은 대게 어렵지 않으나 구현할 때마다 헷갈린다.   
아래와 같이 구현하면 대부분의 경우를 만족시킬 수 있다.   

## 패턴

~~~

    arr := []int{1, 1, 2, 2, 2, 4, 4, 5, 5, 5}
    l := 0
    r := len(arr) // 배열 끝 index보다 1이 커야 한다
    t := 3

    for l != r {
        // floor를 적용, overflow 방지
        m := l + (r-l)/2 
        if arr[m] < t { // 왼쪽을 버리는 조건
            // floor적용에 따른 무한루프 방지를 위해 left에 1을 더함
            l = m + 1
        } else {
            r = m
        }
    }
    if arr[l] == t {
        fmt.Println("found")
    } else {
        fmt.Println("not found")
    }
    fmt.Println("idx:", l)

~~~

위 코드 패턴은 아래의 경우를 모두 만족한다.
1) 정확한 t를 찾는 경우
2) 중복이 있는 경우 left-most를 찾는 경우

right-most를 구하기 위해서는 아래처럼만 수정하면 된다.
~~~
arr[m] < t  =>  arr[m] <= t 
~~~

## 그리고
좀 더 생각해보자.     

이진탐색은 탐색을 지속하면서 왼쪽 혹은 오른쪽을 계속 버리는 것과 같다.   
그러므로 첫 if절 조건은, 왼쪽을 버릴지 오른쪽을 버릴지를 명시하는 것과 같다.  

l = m + 1 과 r = m 코드는 그대로 유지하지 않는 것이 무한루프를 막을 수 있는데 이는 m을 구하는 코드가 floor를 적용한 것과 같기 때문이다.      
만약 ceil을 적용했다면 l = m, r = m - 1 형태로 바뀌어야 한다.   


## 참고
- https://en.wikipedia.org/wiki/Binary_search_algorithm
- https://leetcode.com/problems/search-in-rotated-sorted-array/

